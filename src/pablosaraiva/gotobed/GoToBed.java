package pablosaraiva.gotobed;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Set;

import org.reflections.Reflections;

import pablosaraiva.gotobed.annotations.DoNotSave;
import pablosaraiva.gotobed.annotations.Sleeper;
import pablosaraiva.gotobed.annotations.SleeperId;


public class GoToBed {	
	private BedProvider bedProvider;
	
	public GoToBed(BedProvider bedProvider) {		this.bedProvider = bedProvider;

		Reflections reflections = new Reflections();
		Set<Class<?>> sleeperClasses = reflections.getTypesAnnotatedWith(Sleeper.class);
		for (Class<?> clazz: sleeperClasses) {
			try {
				updateTable(clazz);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}



	public void sleep(Object obj) throws SQLException {
		if (hasId(obj)) {
			update(obj);
		} else {
			insert(obj);
		}
	}

	private void insert(Object obj) throws SQLException {
		Connection conn = bedProvider.getConnection();
//		StringBuilder sb = new StringBuilder();
//		sb.append("INSERT INTO " )
		System.out.println("will insert");
		conn.close();
	}

	private void update(Object obj) {
		System.out.println("will update");
	}

	private boolean hasId(Object obj) {
		
		for (Field f: obj.getClass().getDeclaredFields()) {
			f.setAccessible(true);
			if (f.isAnnotationPresent(SleeperId.class)) {
				try {
					f.setAccessible(true);
					Long id = (Long) f.get(obj);
					if (id != null && id > 0) {
						return true;
					} 
				} catch (IllegalArgumentException | IllegalAccessException e) {
					e.printStackTrace();
				}
			}
			f.setAccessible(false);

		}
		return false;
	}
	
	private void updateTable(Class<?> clazz) throws SQLException {
		if (existsTableForClass(clazz)) {
			updateTableColumnsForFlass(clazz);
		} else {
			createTableForClass(clazz);
		}
	}

	private void createTableForClass(Class<?> clazz) throws SQLException {
		StringBuilder sb = new StringBuilder();
		sb.append("CREATE TABLE ");
		sb.append(tableNameFor(clazz));
		sb.append("(");
		sb.append("ID BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1) PRIMARY KEY");
		for (Field f: clazz.getDeclaredFields()) {
			if (isPersistableAndNotId(f)) {
				String columnType = getStringColumnTypeFor(f.getType());
				sb.append(",");
				sb.append(columnNameFor(f));
				sb.append(" ");
				sb.append(columnType);
			}
		}
		sb.append(")");
		System.out.println(sb.toString());
		Connection conn = bedProvider.getConnection();
		Statement st = conn.createStatement();
		st.execute(sb.toString());
		conn.close();
	}

	private String columnNameFor(Field f) {
		return f.getName().toUpperCase();
	}

	private boolean isPersistableAndNotId(Field f) {
		if (f.isAnnotationPresent(SleeperId.class)) {
			return false;
		} else if (f.isAnnotationPresent(DoNotSave.class)) {
			return false;
		} else if (java.lang.reflect.Modifier.isStatic(f.getModifiers())) {
			return false;
		} else if (!persistenceIsImplementedForClass(f.getType())) {
			return false;
		} else {
			return true;
		}
	}
	

	private boolean persistenceIsImplementedForClass(Class<?> clazz) {
		String columnType = getStringColumnTypeFor(clazz);
		if ((columnType == null) || ("".equals(columnType))) {
			return false;
		} else {
			return true;
		}
	}



	private String getStringColumnTypeFor(Class<?> clazz) {
		if (clazz == String.class) {
			return "VARCHAR(128)";
		} else if (clazz == Long.class || clazz == Long.TYPE) {
			return "BIGINT";
		} else if (clazz == Integer.class || clazz == Integer.TYPE) {
			return "INT";
		} else if (clazz == Boolean.class || clazz == Boolean.TYPE) {
			return "BOOLEAN";
		} else if (clazz == java.util.Date.class) {
			return "DATE";
		} else {
			return null;
		}
	}

	private String tableNameFor(Class<?> clazz) {
		return clazz.getSimpleName().toUpperCase();
	}

	private void updateTableColumnsForFlass(Class<?> clazz) throws SQLException {
		for (Field f: clazz.getDeclaredFields()) {
			if (isPersistableAndNotId(f)) {
				if (!existsColumnFor(f)) {
					createColumnFor(f);
				}
			}
		}
		
	}

	private boolean existsColumnFor(Field f) throws SQLException {
		boolean exists;
		Connection conn = bedProvider.getConnection();
		Statement st = conn.createStatement();
		ResultSet rs = st.executeQuery("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '"+tableNameFor(f.getDeclaringClass())+"' AND  COLUMN_NAME = '"+columnNameFor(f)+"'");
		if (rs.next()) {
			exists = true;
		} else {
			exists = false;
		}
		conn.close();
		return exists;
	}

	private void createColumnFor(Field f) throws SQLException {
		StringBuilder sb = new StringBuilder();
		sb.append("ALTER TABLE ");
		sb.append(tableNameFor(f.getDeclaringClass()));
		sb.append(" ADD ");
		sb.append(columnNameFor(f));
		sb.append(" ");
		sb.append(getStringColumnTypeFor(f.getType()));
		System.out.println(sb.toString());
		Connection conn = bedProvider.getConnection();
		Statement st = conn.createStatement();
		st.execute(sb.toString());
		conn.close();
	}

	private boolean existsTableForClass(Class<?> clazz) throws SQLException {
		boolean exists;
		Connection conn = bedProvider.getConnection();
		Statement st = conn.createStatement();
		ResultSet rs = st.executeQuery("SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '"+tableNameFor(clazz)+"'");
		if (rs.next()) {
			exists = true;
		} else {
			exists = false;
		}
		conn.close();
		return exists;
	}

}
